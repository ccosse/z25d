#!/usr/bin/env python3
def log(msg):
	print(f"{msg}")

def plog(_x):#pretty log
	print(json.dumps(_x, indent=4, sort_keys=True))

if True:
	import AppContext as appContext
	import os,sys,time,threading,websocket,hashlib,io,csv,math
	import json, hmac, hashlib, time, base64
	import requests,datetime
	import locale,pytz
	from pytz import timezone
	import websockets
	import asyncio
	import random,copy
	import json, hmac, hashlib, time, requests
	from requests.auth import AuthBase
	import z25WssMgr as wssMgr
	import z25TxAcctMgr as acctMgr

	SUBSCRIBE_ALL = True
	CURRENCIES_URL = 'https://api.exchange.coinbase.com/currencies'
	WS_CBX_FEED="wss://ws-feed.exchange.coinbase.com"

	inf = open('/home/charlie/z23/cbx_credentials.dat','r')
	contents = inf.read()
	inf.close()
	cbx = eval(contents)
	key_public = cbx['api-key']
	key_secret = cbx['api-secret']

	API_KEY = key_public#PUBLIC
	API_SECRET = key_secret#SIGNING

	GLOBAL_VOL_THRESH = 20
	GLOBAL_PCT_THRESH = 0.85
	DEFAULT_NBIN = 100
	DEFAULT_DT = 60

class Candlestick:
	def __init__(self, P0, MSG):
		self.count = 1
		self.PID = MSG['product_id']
		self.Open = P0#c['price_history'][0][0],
		self.Close = P0#c['price_history'][0][1],
		self.Low = P0#c['price_history'][0][2],
		self.High = P0#c['price_history'][0][3],
		self.Mid = P0#c['price_history'][0][4],
		self.BuyVOL = 0#c['buy_volume_histo'][0]+c['sell_volume_histo'][0],
		self.SellVOL = 0#c['buy_volume_histo'][0]+c['sell_volume_histo'][0],
		self.BuyUSD	= 0#c['buy_usd_histo'][0],
		self.SellUSD = 0#c['sell_usd_histo'][0]
		self.PricePctChange = 0
		
		try:self.pctThresh = MSG['pctThresh']#!!!new cstcks aren't getting curent pctThresh!
		except:self.pctThresh=GLOBAL_PCT_THRESH

		self.t0 = str(datetime.datetime.now().astimezone(timezone('UTC'))).replace(' ','T')
		self.tlast = str(datetime.datetime.now().astimezone(timezone('UTC'))).replace(' ','T')#THIS IS WHAT WE PLOT (slides)
		self.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) + datetime.timedelta(minutes=1)).replace(' ','T')

	def get(self):
		return self.__dict__
		"""
		{ 
			'price': self.Close, 
			'Date': self.t0, 
			'SellVOL': self.SellVOL, 
			'BuyVOL': self.BuyVOL, 
			'High': self.High, 
			'Low': self.Low, 
			'Open': self.Open, 
			'BuyUSD': self.BuyUSD, 
			'SellUSD': self.SellUSD,
			'PricePctChange':self.PricePctChange,
			'pctThresh':self.pctThresh,
			'dict':self.__dict__,
		}	
		"""

	def setThresh(self, pctThresh):
		self.pctThresh = pctThresh

	def update(self, MSG):
		lookAtMe = False
		try:
			self.count += 1
			p = float(MSG['price'])
			self.Close = p#just use this for latest price
			if p > self.High:self.High = p
			elif p < self.Low:self.Low = p
			self.Mid = (self.High + self.Low)/2.
			#
			self.PricePctChange = (p - self.Open)/self.Open * 100.
			#log('{} PCT {}'.format(self.PID, math.fabs(self.PricePctChange)))
			if math.fabs(self.PricePctChange) > self.pctThresh:
				lookAtMe = True
				#log('{} {} {} {}'.format(self.PID,self.PricePctChange,self.pctThresh,math.fabs(self.PricePctChange) > self.pctThresh))
			#
			if True:#WS_CBX_FEED==OLD_WS_FEED:
				if MSG['side'] == 'sell':
					self.SellUSD += float(MSG['last_size'])*float(MSG['price'])
					self.SellVOL += float(MSG['last_size'])
				elif MSG['side'] == 'buy':
					self.BuyUSD += float(MSG['last_size'])*float(MSG['price'])
					self.BuyVOL += float(MSG['last_size'])

		except:
			log(f"CSTK update: {sys.exc_info()}")
		return lookAtMe

def _fetch_open24h_legacy(product_id: str):
	"""Fetch open price for last 24h from legacy Exchange REST stats endpoint.
	Returns float or None on failure. This is a minimal addition and unauthenticated."""
	try:
		url = f"https://api.exchange.coinbase.com/products/{product_id}/stats"
		r = requests.get(url, timeout=5)
		if r.status_code != 200:
			return None
		j = r.json()
		v = j.get('open')
		if v is None:
			return None
		try:
			return float(v)
		except Exception:
			return None
	except Exception:
		return None

class Channel:
	def __init__(self, msg):
		self.first_msg = msg
		self.count = 0
		self.pid = msg['product_id']
		self.currency = msg['product_id'].split('-')[0]
		self.lookAtMePCT = False
		self.lookAtMeVOL = False
		self.pctThresh = GLOBAL_PCT_THRESH#these need to be set for each new channel
		self.volThresh = GLOBAL_VOL_THRESH
		
		#log(f"Channel {self.pid}")
		#
		self.balance = None
		#
		self.subscribed = False
		self.hidden = False
		
		self.price=self.high_24h=self.low_24h=self.open_24h=self.volume_1m=0
		self.price = float(msg['price'])
		self.high_24h = float(msg['high_24h'])
		self.low_24h = float(msg['low_24h'])
		#self.open_24h = float(msg['open_24h'])
		# seed open_24h once from legacy REST
		_pid = getattr(self, 'pid', None) or getattr(self, 'product_id', None)
		if _pid and getattr(self, 'open_24h', None) in (None, 0, 0.0):
			_o = _fetch_open24h_legacy(_pid)
			if _o is not None:
				self.open_24h = _o
		self.volume_1m = float(msg['volume_24h'])/(24.*60.)
		#
		self.nbin=DEFAULT_NBIN#1 min blocks, so minimal data
		self.dt=DEFAULT_DT
		account_sid = None
		auth_token = None
		#self.twilio_client = Client(account_sid, auth_token)
		#
		self.data = []
		msg['pctThresh'] = self.pctThresh
		#log(f"calling cstk {self.price} {msg}")
		cstk = Candlestick(self.price, msg)
		#log(f"cstk = {cstk}")

		self.tz_offset = datetime.timedelta(hours=7)
		cstk.t0 = str(datetime.datetime.now().astimezone(timezone('UTC'))).replace(' ','T')
		cstk.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=1)).replace(' ','T')
		
		self.data.append(cstk)
		for cidx in range(1,self.nbin+1):
			cstk = Candlestick(self.price, msg)
			cstk.t0 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=cidx)).replace(' ','T')
			cstk.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=(cidx+1))).replace(' ','T')
			self.data.append(cstk)
		self.report()
	
	def getPrice(self):
		return self.price
	
	def get_data_for_export(self):
		#self.data=[]
		cstk_data=[]
		export_dict=copy.copy(self.__dict__)
		for didx in range(len(self.data)):
			cstk_data.append(copy.copy(self.data[didx].__dict__))
		export_dict['tz_offset']=str(self.tz_offset)
		export_dict['data']=cstk_data
		return export_dict
	
	def take_data_for_import(self,import_dict):
		try:
			for didx in range(len(import_dict['data'])):#ea cstk data
				cstk=Candlestick(import_dict['price'],{'product_id':import_dict['pid']})#cstk obj
				cstk.__dict__=import_dict['data'][didx]#assign data to obj
				import_dict['data'][didx]=cstk#replace
			self.__dict__=import_dict#replace
		except:print(f"take_data_for_import:\n{import_dict}\n{sys.exc_info()}")

	def setThresh(self, pctThresh, volThresh):
		self.volThresh = volThresh
		self.pctThresh = pctThresh#this is really cstkc prprty, but here for cstk init at cycle
		for cstk in self.data:
			cstk.setThresh(pctThresh)

	def update(self, msg):
		try:
			#log('update {}\t{}'.format(self.pid, msg['price']))
			if msg.get("type") != "ticker": 
				return
			self.count += 1
			self.price = float(msg.get("price", 0.0) or 0.0)
			#self.price = float(msg['price'])
			self.high_24h = float(msg['high_24h'])
			self.low_24h = float(msg['low_24h'])
			self.open_24h = self.open_24h
			self.volume_1m = float(msg['volume_24h'])/(24.*60.)
			if not len(self.data):
				cstk = Candlestick(self.price, msg)
				#log(f"cstk = {cstk}")

				self.tz_offset = datetime.timedelta(hours=7)
				cstk.t0 = str(datetime.datetime.now().astimezone(timezone('UTC'))).replace(' ','T')
				cstk.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=1)).replace(' ','T')

				self.data.append(cstk)
				for cidx in range(1,self.nbin+1):
					cstk = Candlestick(self.price, msg)
					cstk.t0 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=cidx)).replace(' ','T')
					cstk.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=(cidx+1))).replace(' ','T')
					self.data.append(cstk)
				return

			rval = self.data[0].update(msg)#update the leading candlestick; returns lookAtMe
			#log('rval {}'.format(rval))
			isNewForWatch = 0
			if rval == True:
				if not self.lookAtMePCT:
					#log('PCT lookAtMe {}'.format(self.pid))
					self.lookAtMePCT = True
					isNewForWatch = 2
				else:
					pass
					#log('ALREADY watching PCT {} {}'.format(self.pid, self.lookAtMePCT))

			#log('{} VOL {} {}'.format(self.pid, (self.data[0].BuyVOL + self.data[0].SellVOL), self.volume_1m))
			if (self.data[0].BuyVOL + self.data[0].SellVOL) > (self.volThresh * self.volume_1m):
				if not self.lookAtMeVOL:
					#log('VOL lookAtMe {}'.format(self.pid))
					self.lookAtMeVOL = True
					isNewForWatch = 1
					if self.lookAtMePCT:isNewForWatch=3
				else:
					pass
					#log('ALREADY watching VOL {} {}'.format(self.pid, self.lookAtMeVOL))

			return isNewForWatch
		except:
			log(f"Channel.update: {sys.exc_info()}")
			dummy=input('Enter to continue')
		return False
	
	def block_update(self):
		# A lightweight snapshot overlay at top-of-minute; past histo data is just candlesticks; 
		rval = {
			'type': 'block_update',
			'product_id': self.pid,
			'nbin': self.nbin,
			'price_data': [],
			'balance': self.balance,
			'subscribed': self.subscribed,
			'hidden': self.hidden,
			'lookAtMePCT': self.lookAtMePCT,
			'lookAtMeVOL': self.lookAtMeVOL,
			'price': self.price,
			'high_24h': self.high_24h,
			'low_24h': self.low_24h,
			'volume_1m': self.volume_1m,
			'open_24h':self.open_24h
		}

		for cidx in range(len(self.data)):
			#2023-03-18T20:36:07.774Z -- format @js-side
			#tdata = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=cidx)).replace(' ','T')
			rval['price_data'].append(self.data[cidx].get())
		return rval

	def cycle(self):
		self.data.insert(0,Candlestick(self.price, {'product_id':self.pid, 'pctThresh': self.pctThresh}))
		self.data.pop()
		#self.report()
		return self.block_update()

	def report(self):
		#log('report {} len(data): {}'.format(self.pid,len(self.data)))
		oufline = '{}\t{:7d}'.format(self.pid, self.count)
		#for cidx in range(len(self.data)):
		#	#log('cidx {}'.format(cidx))
		#	oufline += '\t{:10.4f}'.format(self.data[cidx].Open)
		#	#log(oufline)
		#log(oufline)

class Z25d:
	def __init__(self):
		print(f"Z25d.__init__")
		#
		self.channels={}
		self.sendlist = []
		self.currencies=[]
		#
		wss = wssMgr.Z25WSSMgr()
		acct = acctMgr.Z25TxAcctMgr()
		self.ctx = appContext.AppContext()
		self.ctx.wss=wss
		self.ctx.acct=acct
		self.ctx.z25=self
		self.ctx.wss.takeCtx(self.ctx)
		self.ctx.acct.takeCtx(self.ctx)
		self.ctx.acct.refresh_accounts()

		self.CBX_FEED=None
		self.cbx_thread = None
		self.subscribed_products_list=['COOKIE-USD','SYND-USD','APR-USD','TREE-USD','RSR-USD']
		self.subscribed_products_string=""
		#
		self.subscribeVol = True
		self.subscribePct = True
		self.subscribeBal = True
		self.subscribeBTC = True
		self.subscribeETH = True
		#

		self.CBX_FEED=None
		self.cbx_thread = None
		self.close_cycler_thread = False
		self.close_cbx_thread = False
		#
		now=datetime.datetime.now()
		secs=now.second
		until_top_of_minute=60-secs
		self.tnext=time.time()+until_top_of_minute
		#
		self.pctThresh = GLOBAL_PCT_THRESH
		self.volThresh = GLOBAL_VOL_THRESH

	def save_state(self):
		log('save_state')
		oufname='cbx.state'
		try:
			ouf=open(oufname,'w')
			oufdict={}
			count=0
			for key in list(self.channels.keys()):
				oufdict[key]=self.channels[key].get_data_for_export()
				count+=1
			ouf.write(json.dumps(oufdict))
			ouf.close()
			log(f"Wrote {count} channels to {oufname}")
		except:
			log(f"Error saving state: {sys.exc_info()}")
	
	def load_state(self):
		log('load_state')
		infname='cbx.state'
		count=0
		try:
			inf=open(infname)
			_channels=json.loads(inf.read())
			inf.close()
			for key in list(_channels.keys()):
				try:
					if key in list(self.channels.keys()):
						self.channels[key].take_data_for_import(_channels[key])
						count+=1
					else:
						self.channels[key]=Channel(_channels[key]['first_msg'])
						self.channels[key].take_data_for_import(_channels[key])
						count+=1
				except:log(f"Error loading channel: {key} {sys.exc_info()}")
			log(f"Loaded {count} channels from {infname}")
		except:
			log(f"Error loading state: {sys.exc_info()}")
	def getChannel(self,pid):
		print(f"z25d.getChannel: {pid}")
		print(f"{self.channels.keys()}")
		return self.channels[pid]
	
	def start(self):
		self.load_state()
		response = requests.get(CURRENCIES_URL).json()
		log(f"received {len(response)} currencies")
		for i in range(len(response)):
			if response[i]['details']['type'] == 'crypto':
				#print(response[i]['id'])
				self.currencies.append(response[i]['id'])
				subscribeCondition=False
				if response[i]['id']=='BTC' and self.subscribeBTC:subscribeCondition=True
				if f"{response[i]['id']}-USD" in self.subscribed_products_list:subscribeCondition=True
				if subscribeCondition or SUBSCRIBE_ALL:
					self.subscribed_products_list.append(f"{response[i]['id']}-USD")
					self.subscribed_products_string+=f"{response[i]['id']}-USD"
					if i<len(response)-1:
						self.subscribed_products_string+=","

		cycler_thread = threading.Thread(target=self.channel_cycler)
		cycler_thread.start()
		log(f"channel_cycler started")
		asyncio.run(self.ctx.wss.xmain())

	def cycle_channels(self):
		log('cycling {} channels'.format(len(self.channels)))
		collective_block_update = {'type':'collective_block_update',}
		lookAtMeCountPCT = 0
		lookAtMeCountVOL = 0
		for c in self.channels.values():
			#log('{} {} {:.3f}'.format(c.pid, c.count, float(c.price)))
			retain = False
			retain_reasons = []
			block_update = c.cycle()

			if c.pid == 'BTC-USD' and self.subscribeBTC:
				retain_reasons.append(1)
				retain = True
			
			if c.pid == 'ETH-USD' and self.subscribeETH:
				retain_reasons.append(2)
				retain = True
			
			if c.pid in self.sendlist:
				retain_reasons.append(3)
				retain = True

			if c.lookAtMeVOL == True and self.subscribeVol:
				lookAtMeCountVOL += 1
				if self.subscribeVol == True:
					retain_reasons.append(4)
					retain = True
			
			if c.lookAtMePCT == True and self.subscribePct:
				lookAtMeCountPCT += 1
				if self.subscribePct == True:
					retain_reasons.append(5)
					retain = True

			if c.balance == True and self.subscribeBal == True:
				retain_reasons.append(6)
				retain = True
			
			if c.subscribed == True:#ie manually subscribed, and persistent
				retain_reasons.append(7)
				retain = True	

			if retain == True:
				#log('retaining {} {}'.format(c.pid, retain_reasons))
				collective_block_update[c.pid] = block_update

		log('sendlist {}'.format(self.sendlist))
		log('lookAtMeCountVOL: {} lookAtMeCountPCT: {}'.format(lookAtMeCountVOL,lookAtMeCountPCT))
		#log(f"CONNECTIONS: {self.ctx.wss.connections}")
		for wskey in list(self.ctx.wss.connections):
			#log(f"appending block_update to queues: {wskey} {json.dumps(collective_block_update)}")
			self.ctx.wss.queues[wskey].append(json.dumps(collective_block_update))

	def channel_cycler(self):
		#log('self.tnext = {:.2f} ({:.2f})'.format(self.tnext,(self.tnext-time.time())))
		while not self.close_cycler_thread:
			if time.time() > self.tnext:

				self.cycle_channels()

				now=datetime.datetime.now()
				secs=now.second
				until_top_of_minute=60-secs

				self.tnext=time.time()+until_top_of_minute#put here so not called 2x from somewhere else during update
				#log('self.tnext = {:.2f} ({:.2f})'.format(self.tnext,(self.tnext-time.time())))

			dt=(self.tnext-time.time())
			#log('sleeping for {:.2f} sec'.format(dt))
			time.sleep(dt)
		self.close_cycler_thread = False

	def update_channel(self, msg):
		#log(f"update_channel {msg['product_id']}")
		if msg['product_id'] in list(self.channels):
			#log(f"updating channel {msg['product_id']}")
			rval = self.channels[msg['product_id']].update(msg)#rval=isNewForWatch (either Vol or Pct or Both)
			sendFlag=False
			if self.subscribePct == True and (rval == 2 or rval == 3):sendFlag=True
			elif self.subscribeVol == True and (rval == 1 or rval == 3):sendFlag=True
			elif msg['product_id']=='BTC-USD' and self.subscribeBTC:sendFlag=True

			#log(f"sendFlag = {sendFlag}")
			if sendFlag == True:#0,1,2,3 no,newvol,newpct,newboth then we bring client up-to-date with this channel immedieately (vs top of minute) 1x
				#good place to add b/c only called 1x on first NewForWatch
				if not msg['product_id'] in self.sendlist:
					log('CULPRIT rval = {} {} {} {}'.format(rval,msg['product_id'],self.subscribePct,self.subscribeVol))
					self.sendlist.append(msg['product_id'])
					#self.sendBlockUpdateNow()#  either way its sending block update below, so this appears 2B redundant
				for wskey in list(self.ctx.wss.connections):
					#log(f"sending for {msg['product_id']}")
					self.ctx.wss.queues[wskey].append(json.dumps(self.channels[msg['product_id']].block_update()))
		else:
			log(f"CREATE {msg['product_id'] in self.channels}\t{msg['product_id']}")
			c = Channel(msg)
			#log(c)
			try:
				c.balance = 0#float(self.THE_M22.accounts[c.currency]['balance'])
			except:
				log(sys.exc_info())
				c.balance = 0
				#log(self.THE_M22.accounts)
			#log(f"{self.channels}")
			#log(f"Channel = {c.pid} Balance = {c.balance}")
			self.channels[c.pid] = c#Channel(msg)#does update
			#log(self.channels[c.pid])

	def subscribe_new(self):
		channel = 'ticker'
		timestamp = str(int(time.time()))
		subscribe_msg = {
			'type': 'subscribe',
			"channels": [
   			 { "name": "ticker", "product_ids": self.subscribed_products_list }
  			],
			'api_key': API_KEY,
			'timestamp': timestamp,
			'signature': self.sign_message(timestamp + channel + self.subscribed_products_string)
		}
		#plog(subscribe_msg)
		subscribe_msg = json.dumps(subscribe_msg)

		def on_open(ws):
			self.CBX_FEED.send(subscribe_msg)
		
		def mkOldFmt(msg):
			#log(f"mkOldFmt")
			try:
				rval ={
					"best_ask": "0",
					"best_ask_size": "0",
					"best_bid": "0",
					"best_bid_size": "0",
					"high_24h": msg["high_24h"],
					"last_size": msg["last_size"],
					"low_24h": msg["low_24h"],
					"open_24h": str(self.channels[msg["product_id"]].open_24h) if msg.get("product_id") in self.channels else "0",
					"price": msg["price"],
					"product_id": msg["product_id"],
					"sequence": msg["sequence"],
					"side": msg["side"],
					"time": msg["time"],
					"trade_id": 0,
					"type": "ticker",
					"volume_24h": msg["volume_24h"],
					"volume_30d": msg["volume_30d"]
				}
				return rval
			except:
				log(f"{sys.exc_info()}")
			return None

		def on_message(ws, raw_msg):
			msg=json.loads(raw_msg)#ticker update from coinbase
			#plog(msg)
			if msg['type']=="error":
				#log(f"{raw_msg}")
				product_id=msg['reason'].split(" ")[0]
				self.subscribed_products_list.remove(product_id)
				return
			
			elif msg['type']=='subscriptions':
				self.subscribed_products_list=msg['channels']['product_ids']
				return

			elif msg['type']!='ticker':
				log(f'not a ticker message {raw_msg}')
				return
			
			msg=mkOldFmt(msg)
			#plog(msg)
			#print(f"{self.ctx.wss.connections}")
			if msg['product_id'] == 'BTC-USD' and self.subscribeBTC:
				for wskey in self.ctx.wss.connections:
					self.ctx.wss.queues[wskey].append(json.dumps(msg))
					#log(f"self.ctx.wss.queues = {self.ctx.wss.queues}")
			elif msg['product_id'] == 'ETH-USD' and self.subscribeETH:
				for wskey in self.ctx.wss.connections:
					self.ctx.wss.queues[wskey].append(json.dumps(msg))
			elif msg['product_id'] in self.sendlist:#msg['product_id'] in self.channels and (self.channels[msg['product_id']].lookAtMePCT == True or self.channels[msg['product_id']].lookAtMeVOL == True):
				for wskey in self.ctx.wss.connections:#NEED:sendlist is currently default GRT only
					self.ctx.wss.queues[wskey].append(json.dumps(msg))
			
			#print(f"{len(self.ctx.wss.queues[wskey])}")
			self.update_channel(msg)

		def on_close(ws):
			log('Websocket connection closed')

		self.CBX_FEED = websocket.WebSocketApp(
			WS_CBX_FEED,
			on_message=on_message
		)
		self.CBX_FEED.on_open = on_open
		self.CBX_FEED.on_close = on_close
		self.CBX_FEED.run_forever()

	def restartCBX(self):
		log(f"restartCBX")
		if self.cbx_thread:
			#self.cbx_thread.join()
			#time.sleep(1)
			self.cbx_thread=None
			self.CBX_FEED=None
		
		self.cbx_thread = threading.Thread(target=self.subscribe_new)
		#websocket_thread.daemon=True
		log(f"calling cbx_thread.start()")
		self.cbx_thread.start()

	def sign_message(self,message):
		message = hmac.new(API_SECRET.encode('utf-8'), message.encode('utf-8'), digestmod=hashlib.sha256).hexdigest()
		return message

	def sendZ25D(self):
		log('sendZ25D')
		z25state = {#these are client subscriptions (sets of pids of which to send), not cbx
			'type':'z25d',
			'subscribeVol':self.subscribeVol,
			'subscribePct':self.subscribePct,
			'subscribeBal':self.subscribeBal,
			'subscribeBTC':self.subscribeBTC,
			'subscribeETH':self.subscribeETH,
			'pctThresh':self.pctThresh,
			'volThresh':self.volThresh,
			'nbin':DEFAULT_NBIN,
			'dt':DEFAULT_DT,
			'numChannels':len(list(self.channels.keys())),
			'cbxMsgsReceived':0,
			'cbxMsgsSent':0,
			'clientMsgsReceived':0,
			'clientMsgsSent':0,
			'sendlist':self.sendlist,
		}
		json_state = json.dumps(z25state)
		log(json_state)
		for wskey in list(self.ctx.wss.connections):
			log('sending json_state to {}'.format(wskey))
			self.ctx.wss.queues[wskey].append(json_state)

	def sendBlockUpdateNow(self):
		collective_block_update = {'type':'collective_block_update',}
		lookAtMeCountVOL=0
		lookAtMeCountPCT=0
		for c in self.channels.values():
			#log('{} {} {:.3f}'.format(c.pid, c.count, float(c.price)))
			retain = False

			if c.pid == 'BTC-USD' and self.subscribeBTC:
				retain = True
			
			if c.pid == 'ETH-USD' and self.subscribeETH:
				retain = True
			
			if c.lookAtMeVOL:
				lookAtMeCountVOL += 1
				if self.subscribeVol:
					retain = True
			
			if c.lookAtMePCT:
				lookAtMeCountPCT += 1
				if self.subscribePct:
					retain = True

			if c.balance and self.subscribeBal:
				retain = True
			
			if c.subscribed:#ie manually subscribed, and persistent
				retain = True	

			if retain == True:
				collective_block_update[c.pid] = c.block_update()

		#log('lookAtMeCountVOL: {} lookAtMeCountPCT: {}'.format(lookAtMeCountVOL,lookAtMeCountPCT))
		for wskey in list(self.ctx.wss.connections):
			self.ctx.wss.queues[wskey].append(json.dumps(collective_block_update))

if __name__=="__main__":
	z25d=Z25d()
	try:
		z25d.start()
	except:
		z25d.save_state()
		sys.exit()

"""
{
	"best_ask": "111670.07",
	"best_ask_size": "0.10681918",
	"best_bid": "111670.06",
	"best_bid_size": "0.01732166",
	"high_24h": "111968.52",
	"last_size": "0.00118205",
	"low_24h": "110693.01",
	"open_24h": "111042.13",
	"price": "111670.06",
	"product_id": "BTC-USD",
	"sequence": 114244292687,
	"side": "sell",
	"time": "2025-10-25T23:17:05.912923Z",
	"trade_id": 891776535,
	"type": "ticker",
	"volume_24h": "1423.09388994",
	"volume_30d": "241615.25295228"
}
"""