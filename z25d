#!/usr/bin/env python3
def log(msg):
	print(f"{msg}")

def plog(_x):#pretty log
	print(json.dumps(_x, indent=4, sort_keys=True))

if True:
	import AppContext as appContext
	import os,sys,time,threading,websocket,hashlib,io,csv,math
	import json, hmac, hashlib, time, base64
	import requests,datetime
	import locale,pytz
	from pytz import timezone
	import websockets
	import asyncio
	import random,copy
	import json, hmac, hashlib, time, requests
	from requests.auth import AuthBase
	import z25WssMgr as wssMgr
	import z25TxAcctMgr as acctMgr

	SUBSCRIBE_ALL = True
	CURRENCIES_URL = 'https://api.exchange.coinbase.com/currencies'
	WS_CBX_FEED="wss://ws-feed.exchange.coinbase.com"

	inf = open('/home/charlie/z23/cbx_credentials.dat','r')
	contents = inf.read()
	inf.close()
	cbx = eval(contents)
	key_public = cbx['api-key']
	key_secret = cbx['api-secret']

	API_KEY = key_public#PUBLIC
	API_SECRET = key_secret#SIGNING

	GLOBAL_VOL_THRESH = 40
	GLOBAL_PCT_THRESH = 1.0
	DEFAULT_NBIN = 100
	DEFAULT_DT = 60

class Candlestick:
	def __init__(self, P0, MSG):
		self.count = 1
		self.PID = MSG['product_id']
		self.Open = P0#c['price_history'][0][0],
		self.Close = P0#c['price_history'][0][1],
		self.Low = P0#c['price_history'][0][2],
		self.High = P0#c['price_history'][0][3],
		self.Mid = P0#c['price_history'][0][4],
		self.BuyVOL = 0#c['buy_volume_histo'][0]+c['sell_volume_histo'][0],
		self.SellVOL = 0#c['buy_volume_histo'][0]+c['sell_volume_histo'][0],
		self.BuyUSD	= 0#c['buy_usd_histo'][0],
		self.SellUSD = 0#c['sell_usd_histo'][0]
		self.PricePctChange = 0
		
		try:self.pctThresh = MSG['pctThresh']#!!!new cstcks aren't getting curent pctThresh!
		except:self.pctThresh=GLOBAL_PCT_THRESH

		self.t0 = str(datetime.datetime.now().astimezone(timezone('UTC'))).replace(' ','T')
		self.tlast = str(datetime.datetime.now().astimezone(timezone('UTC'))).replace(' ','T')#THIS IS WHAT WE PLOT (slides)
		self.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) + datetime.timedelta(minutes=1)).replace(' ','T')
		self.time_last = time.time()

	def get(self):
		return self.__dict__
		"""
		{ 
			'price': self.Close, 
			'Date': self.t0, 
			'SellVOL': self.SellVOL, 
			'BuyVOL': self.BuyVOL, 
			'High': self.High, 
			'Low': self.Low, 
			'Open': self.Open, 
			'BuyUSD': self.BuyUSD, 
			'SellUSD': self.SellUSD,
			'PricePctChange':self.PricePctChange,
			'pctThresh':self.pctThresh,
			'dict':self.__dict__,
		}	
		"""

	def setThresh(self, pctThresh):
		self.pctThresh = pctThresh

	def update(self, MSG):
		lookAtMe = False
		try:
			self.count += 1
			p = float(MSG['price'])
			self.Close = p#just use this for latest price
			if p > self.High:self.High = p
			elif p < self.Low:self.Low = p
			self.Mid = (self.High + self.Low)/2.
			#
			self.PricePctChange = (p - self.Open)/self.Open * 100.
			#log('{} PCT {}'.format(self.PID, math.fabs(self.PricePctChange)))
			if math.fabs(self.PricePctChange) > self.pctThresh:
				lookAtMe = True
				#log('{} {} {} {}'.format(self.PID,self.PricePctChange,self.pctThresh,math.fabs(self.PricePctChange) > self.pctThresh))
				print(f"{self.PID} {self.PricePctChange} {self.pctThresh} {math.fabs(self.PricePctChange) > self.pctThresh}")

			if MSG['side'] == 'sell':
				self.SellUSD += float(MSG['last_size'])*float(MSG['price'])
				self.SellVOL += float(MSG['last_size'])
			elif MSG['side'] == 'buy':
				self.BuyUSD += float(MSG['last_size'])*float(MSG['price'])
				self.BuyVOL += float(MSG['last_size'])

		except:
			log(f"CSTK update: {sys.exc_info()}")
		return lookAtMe

def _fetch_open24h_legacy(product_id: str):
	"""Fetch open price for last 24h from legacy Exchange REST stats endpoint.
	Returns float or None on failure. This is a minimal addition and unauthenticated."""
	try:
		url = f"https://api.exchange.coinbase.com/products/{product_id}/stats"
		r = requests.get(url, timeout=5)
		if r.status_code != 200:
			return None
		j = r.json()
		v = j.get('open')
		if v is None:
			return None
		try:
			return float(v)
		except Exception:
			return None
	except Exception:
		return None

class Channel:
	def __init__(self, msg):
		self.first_msg = msg
		self.count = 0
		self.pid = msg['product_id']
		self.currency = msg['product_id'].split('-')[0]
		self.lookAtMePCT = False
		self.lookAtMeVOL = False
		self.pctThresh = GLOBAL_PCT_THRESH#these need to be set for each new channel
		self.volThresh = GLOBAL_VOL_THRESH
		
		#log(f"Channel {self.pid}")
		#
		self.balance = None
		#
		self.subscribed = False
		self.hidden = False
		
		self.price=self.high_24h=self.low_24h=self.open_24h=self.volume_1m=0
		self.price = float(msg['price'])
		self.high_24h = float(msg['high_24h'])
		self.low_24h = float(msg['low_24h'])
		#self.open_24h = float(msg['open_24h'])
		# seed open_24h once from legacy REST
		_pid = getattr(self, 'pid', None) or getattr(self, 'product_id', None)
		if _pid and getattr(self, 'open_24h', None) in (None, 0, 0.0):
			_o = _fetch_open24h_legacy(_pid)
			if _o is not None:
				self.open_24h = _o
		self.volume_1m = float(msg['volume_24h'])/(24.*60.)
		#
		self.nbin=DEFAULT_NBIN#1 min blocks, so minimal data
		self.dt=DEFAULT_DT
		account_sid = None
		auth_token = None
		#self.twilio_client = Client(account_sid, auth_token)
		#
		self.data = []
		msg['pctThresh'] = self.pctThresh
		#log(f"calling cstk {self.price} {msg}")
		cstk = Candlestick(self.price, msg)
		#log(f"cstk = {cstk}")

		self.tz_offset = datetime.timedelta(hours=7)
		cstk.t0 = str(datetime.datetime.now().astimezone(timezone('UTC'))).replace(' ','T')
		cstk.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=1)).replace(' ','T')
		
		self.data.append(cstk)
		for cidx in range(1,self.nbin+1):
			cstk = Candlestick(self.price, msg)
			cstk.t0 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=cidx)).replace(' ','T')
			cstk.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=(cidx+1))).replace(' ','T')
			self.data.append(cstk)
		self.report()
	
	def getPrice(self):
		return self.price
	
	def get_data_for_export(self):
		#self.data=[]
		cstk_data=[]
		export_dict=copy.copy(self.__dict__)
		for didx in range(len(self.data)):
			cstk_data.append(copy.copy(self.data[didx].__dict__))
		export_dict['tz_offset']=str(self.tz_offset)
		export_dict['data']=cstk_data
		return export_dict
	
	def take_data_for_import(self,import_dict):
		try:
			for didx in range(len(import_dict['data'])):#ea cstk data
				cstk=Candlestick(import_dict['price'],{'product_id':import_dict['pid']})#cstk obj
				cstk.__dict__=import_dict['data'][didx]#assign data to obj
				import_dict['data'][didx]=cstk#replace
			self.__dict__=import_dict#replace
		except:print(f"take_data_for_import:\n{import_dict}\n{sys.exc_info()}")

	def setThresh(self, pctThresh, volThresh):
		self.volThresh = volThresh
		self.pctThresh = pctThresh#this is really cstkc prprty, but here for cstk init at cycle
		for cstk in self.data:
			cstk.setThresh(pctThresh)

	def update(self, msg):
		try:
			#log('update {}\t{}'.format(self.pid, msg['price']))
			if msg.get("type") != "ticker": 
				return 0
			self.count += 1
			self.price = float(msg.get("price", 0.0) or 0.0)
			#self.price = float(msg['price'])
			self.high_24h = float(msg['high_24h'])
			self.low_24h = float(msg['low_24h'])
			self.open_24h = self.open_24h
			self.volume_1m = float(msg['volume_24h'])/(24.*60.)
			if not len(self.data):
				cstk = Candlestick(self.price, msg)
				#log(f"cstk = {cstk}")

				self.tz_offset = datetime.timedelta(hours=7)
				cstk.t0 = str(datetime.datetime.now().astimezone(timezone('UTC'))).replace(' ','T')
				cstk.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=1)).replace(' ','T')

				self.data.append(cstk)
				for cidx in range(1,self.nbin+1):
					cstk = Candlestick(self.price, msg)
					cstk.t0 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=cidx)).replace(' ','T')
					cstk.t1 = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=(cidx+1))).replace(' ','T')
					self.data.append(cstk)
				return 0

			rval = self.data[0].update(msg)#update the leading candlestick; returns lookAtMe
			#log('rval {}'.format(rval))
			isNewForWatch = 0#1=Vol,2=Pct,3=Vol&&Pct
			if rval == True:
				if not self.lookAtMePCT:
					#log('PCT lookAtMe {}'.format(self.pid))
					self.lookAtMePCT = True
					isNewForWatch = 2
				else:
					pass
					#log('ALREADY watching PCT {} {}'.format(self.pid, self.lookAtMePCT))

			#log('{} VOL {} {}'.format(self.pid, (self.data[0].BuyVOL + self.data[0].SellVOL), self.volume_1m))
			if (self.data[0].BuyVOL + self.data[0].SellVOL) > (self.volThresh * self.volume_1m):
				if not self.lookAtMeVOL:
					#log('VOL lookAtMe {}'.format(self.pid))
					self.lookAtMeVOL = True
					isNewForWatch = 1
					if self.lookAtMePCT:isNewForWatch=3
				else:
					pass
					#log('ALREADY watching VOL {} {}'.format(self.pid, self.lookAtMeVOL))

			return isNewForWatch
		except:
			log(f"Channel.update: {sys.exc_info()}")
			dummy=input('Enter to continue')
		return 0
	
	def block_update(self):
		# A lightweight snapshot overlay at top-of-minute; past histo data is just candlesticks; 
		rval = {
			'type': 'block_update',
			'product_id': self.pid,
			'nbin': self.nbin,
			'price_data': [],
			'balance': self.balance,
			'subscribed': self.subscribed,
			'hidden': self.hidden,
			'lookAtMePCT': self.lookAtMePCT,
			'lookAtMeVOL': self.lookAtMeVOL,
			'price': self.price,
			'high_24h': self.high_24h,
			'low_24h': self.low_24h,
			'volume_1m': self.volume_1m,
			'open_24h':self.open_24h
		}

		for cidx in range(len(self.data)):
			#2023-03-18T20:36:07.774Z -- format @js-side
			#tdata = str(datetime.datetime.now().astimezone(timezone('UTC')) - datetime.timedelta(minutes=cidx)).replace(' ','T')
			rval['price_data'].append(self.data[cidx].get())
		return rval

	def cycle(self):
		self.data.insert(0,Candlestick(self.price, {'product_id':self.pid, 'pctThresh': self.pctThresh}))
		self.data.pop()
		return self.block_update()

	def report(self):
		#log('report {} len(data): {}'.format(self.pid,len(self.data)))
		log(f"Channel.report: {self.pid} count: {self.count} self.data: {len(self.data)}")
		#for cidx in range(len(self.data)):
		#	#log('cidx {}'.format(cidx))
		#	oufline += '\t{:10.4f}'.format(self.data[cidx].Open)
		#	#log(oufline)
		#log(oufline)

class Z25d:
	def __init__(self):
		print(f"Z25d.__init__")
		#
		self.channels={}
		self.sendlist = []
		self.currencies=[]
		self.hotlist={}
		#
		wss = wssMgr.Z25WSSMgr()
		acct = acctMgr.Z25TxAcctMgr()
		self.ctx = appContext.AppContext()
		self.ctx.wss=wss
		self.ctx.acct=acct
		self.ctx.z25=self
		self.ctx.wss.takeCtx(self.ctx)
		self.ctx.acct.takeCtx(self.ctx)
		self.ctx.acct.refresh_accounts()

		self.CBX_FEED=None
		self.cbx_thread = None
		self.close_cycler_thread = False
		self.close_cbx_thread = False
		self.subscribed_products_list=[]
		self.subscribed_products_string=""
		#
		self.subscribeVol = True
		self.subscribePct = True
		self.subscribeBal = True
		self.subscribeBTC = True
		self.subscribeETH = True
		#
		now=datetime.datetime.now()
		secs=now.second
		until_top_of_minute=60-secs
		self.tnext=time.time()+until_top_of_minute
		#
		self.pctThresh = GLOBAL_PCT_THRESH
		self.volThresh = GLOBAL_VOL_THRESH
		self.t_last_ticker = time.time()

	def save_state(self):
		log('save_state')
		oufname='cbx.state'
		try:
			ouf=open(oufname,'w')
			oufdict={}
			count=0
			for key in list(self.channels.keys()):
				oufdict[key]=self.channels[key].get_data_for_export()
				count+=1
			ouf.write(json.dumps(oufdict))
			ouf.close()
			log(f"Wrote {count} channels to {oufname}")
		except:
			log(f"Error saving state: {sys.exc_info()}")
	
	def load_state(self):
		log('load_state')
		infname='cbx.state'
		count=0
		try:
			inf=open(infname)
			_channels=json.loads(inf.read())
			inf.close()
			count=0
			total=len(_channels.keys())
			for key in list(_channels.keys()):
				log(f"load_state loading {key} {count}/{total}")
				try:
					if key in list(self.channels.keys()):
						self.channels[key].take_data_for_import(_channels[key])
						count+=1
					else:
						self.channels[key]=Channel(_channels[key]['first_msg'])
						self.channels[key].take_data_for_import(_channels[key])
						count+=1
				except:
					log(f"Error loading channel: {key} {sys.exc_info()}")
					break
			log(f"Loaded {count} channels from {infname}")
		except:
			log(f"Error loading state: {sys.exc_info()}")

	def getChannel(self,pid):
		print(f"z25d.getChannel: {pid}")
		print(f"{self.channels.keys()}")
		return self.channels[pid]
	
	def update_hotlist(self,pid):
		try:
			score=4
			c=self.getChannel(pid)
			dt = time.time() - c.data[0].time_last
			log(f"update_hotlist: {pid} {dt}")
			
			#check if fish-on!
			criteria0 = c.data[0].PricePctChange>1.5
			criteria1 = c.data[0].PricePctChange>1 and c.data[1].PricePctChange>0.85 and c.data[2].PricePctChange>0
			criteria2 = (dt < 15) and c.data[0].PricePctChange>0.5 and c.data[1].PricePctChange>0.85 and c.data[2].PricePctChange>0
			criteria3 = (dt < 30) and c.data[0].PricePctChange>1.0 and c.data[1].PricePctChange>0.85 and c.data[2].PricePctChange>0
			if score==4:
				if criteria0 or criteria1 or criteria2 or criteria3:
					#print('{} {} {}'.format(criteria1,criteria2,criteria3))
					if time.time()-c['tlast_text_message'] > self.text_message_speed_limit:
						msg_text='!!! FISH-ON (UP) !!! http://pro.coinbase.com/trade/{}  {} {} {} {}'.format(pid,criteria0,criteria1,criteria2,criteria3)
						log(msg_text)
						if self.texting_enabled and float(c['buy_usd_total'])/1E6 > 0.01:
							self.send_text(pid,msg_text)
						c['tlast_text_message']=time.time()
			sorted_keys=list(self.hotlist.keys())
			if pid in self.hotlist.keys():
				self.hotlist[pid]['score']=score
				self.hotlist[pid]['channel']=c
				if score > self.hotlist[pid]['high_score']:
					self.hotlist[pid]['high_score']=score
				#log('updated {}'.format(pid))
			else:
				self.hotlist[pid]={'score':0,'high_score':0,'channel':c}
				#log('added {}'.format(pid))

			#do sort here to upgrade last item, else just pops off and doesn't make list
			kvlist={}
			for k,v in self.hotlist.items():
				kvlist[k]=v['score']+v['high_score']#sorting by score+high_score -> avoids 2 nested sorts w/ almost same result
			hotkvs={k: v for k, v in sorted(kvlist.items(), key=lambda item: item[1])}
			sorted_keys=list(hotkvs.keys())#higher score first
			sorted_keys.reverse()
			#log(sorted_keys)
			while len(sorted_keys) > 10:
				sk=sorted_keys.pop()
				del(self.hotlist[sk])#changed from pid -> sk
				#log('removed {}'.format(sk))
			#now, after have desired list, want to sort from + -> - by price_history[0][5] (this works beautifully)
			kvlist={}
			for k,v in self.hotlist.items():
				kvlist[k]=v['channel'].data[0].PricePctChange
			hotkvs={k: v for k, v in sorted(kvlist.items(), key=lambda item: item[1])}
			sorted_keys=list(hotkvs.keys())#higher score first
			sorted_keys.reverse()
			msg={
				'type':'update_hotlist',
				'sorted_keys':sorted_keys,
				#'hotlist':self.hotlist,#dict
			}
			return json.dumps(msg)
		except:
			log(sys.exc_info())
		return {}
		
	def start(self):
		self.load_state()
		response = requests.get(CURRENCIES_URL).json()
		log(f"received {len(response)} currencies")
		for i in range(len(response)):
			if response[i]['details']['type'] == 'crypto':
				#print(response[i]['id'])
				self.currencies.append(response[i]['id'])
				subscribeCondition=False
				if response[i]['id']=='BTC' and self.subscribeBTC:subscribeCondition=True
				if f"{response[i]['id']}-USD" in self.subscribed_products_list:subscribeCondition=True
				if subscribeCondition or SUBSCRIBE_ALL:
					self.subscribed_products_list.append(f"{response[i]['id']}-USD")
					self.subscribed_products_string+=f"{response[i]['id']}-USD"
					if i<len(response)-1:
						self.subscribed_products_string+=","

		cycler_thread = threading.Thread(target=self.channel_cycler)
		cycler_thread.start()
		log(f"channel_cycler started")
		asyncio.run(self.ctx.wss.xmain())

	def cycle_channels(self):
		log('cycling {} channels'.format(len(self.channels)))
		collective_block_update = {'type':'collective_block_update',}
		lookAtMeCountPCT = 0
		lookAtMeCountVOL = 0
		for c in self.channels.values():
			#log('{} {} {:.3f}'.format(c.pid, c.count, float(c.price)))
			retain = False
			retain_reasons = []
			block_update = c.cycle()

			if c.pid == 'BTC-USD' and self.subscribeBTC:
				retain_reasons.append(1)
				retain = True
			
			if c.pid == 'ETH-USD' and self.subscribeETH:
				retain_reasons.append(2)
				retain = True
			
			if c.pid in self.sendlist:
				retain_reasons.append(3)
				retain = True

			if c.lookAtMeVOL == True and self.subscribeVol:
				lookAtMeCountVOL += 1
				retain_reasons.append(4)
				retain = True
			
			if c.lookAtMePCT == True and self.subscribePct:
				lookAtMeCountPCT += 1
				retain_reasons.append(5)
				retain = True
			"""
			if c.balance == True and self.subscribeBal == True:
				retain_reasons.append(6)
				retain = True
			"""
			if c.subscribed == True:#ie manually subscribed, and persistent
				retain_reasons.append(7)
				retain = True	

			if c.pid in list(self.ctx.acct.order_keys):
				print(f"retaining {c.pid} b/c has order")
				retain = True

			if retain == True:
				#log('retaining {} {}'.format(c.pid, retain_reasons))
				collective_block_update[c.pid] = block_update

		#log('sendlist {}'.format(self.sendlist))
		log('lookAtMeCountVOL: {} lookAtMeCountPCT: {}'.format(lookAtMeCountVOL,lookAtMeCountPCT))
		#log(f"CONNECTIONS: {self.ctx.wss.connections}")
		"""
		for wskey in list(self.ctx.wss.connections):
			log(f"appending block_update to queues: {wskey} {json.dumps(collective_block_update)}")
			self.ctx.wss.queues[wskey].append(json.dumps(collective_block_update))
		"""

	def channel_cycler(self):
		#log('self.tnext = {:.2f} ({:.2f})'.format(self.tnext,(self.tnext-time.time())))
		while not self.close_cycler_thread:
			if time.time() > self.tnext:

				self.cycle_channels()

				now=datetime.datetime.now()
				secs=now.second
				until_top_of_minute=60-secs

				self.tnext=time.time()+until_top_of_minute#put here so not called 2x from somewhere else during update
				#log('self.tnext = {:.2f} ({:.2f})'.format(self.tnext,(self.tnext-time.time())))

			dt=(self.tnext-time.time())
			#log('sleeping for {:.2f} sec'.format(dt))
			time.sleep(dt)
		self.close_cycler_thread = False

	def update_channel(self, msg):
		#log(f"update_channel {msg['product_id']}")
		if msg['product_id'] in list(self.channels):
			#log(f"updating channel {msg['product_id']}")
			
			#rvals from candlestick[0](Pct) and channel(Vol) 1=Vol,2=Pct,3=Vol&&Pct
			rval = self.channels[msg['product_id']].update(msg)#rval=isNewForWatch (either Vol or Pct or Both)
			sendFlag=False
			if self.subscribePct == True and (rval == 2 or rval == 3):sendFlag=True
			elif self.subscribeVol == True and (rval == 1 or rval == 3):sendFlag=True
			elif msg['product_id'] in self.sendlist:sendFlag=True
			elif msg['product_id']=='BTC-USD' and self.subscribeBTC:sendFlag=True#throttle btc?

			#log(f"sendFlag = {sendFlag}")
			if sendFlag == True:#0,1,2,3 no,newvol,newpct,newboth then we bring client up-to-date with this channel immedieately (vs top of minute) 1x
				#good place to add b/c only called 1x on first NewForWatch
				for wskey in list(self.ctx.wss.connections):
					#log(f"sending for {msg['product_id']}")
					self.ctx.wss.queues[wskey].append(json.dumps(self.channels[msg['product_id']].block_update()))
		else:
			log(f"CREATE {msg['product_id'] in self.channels}\t{msg['product_id']}")
			c = Channel(msg)
			#log(c)
			try:
				c.balance = 0#float(self.THE_M22.accounts[c.currency]['balance'])
			except:
				log(sys.exc_info())
				c.balance = 0
				#log(self.THE_M22.accounts)
			#log(f"{self.channels}")
			#log(f"Channel = {c.pid} Balance = {c.balance}")
			self.channels[c.pid] = c#Channel(msg)#does update
			#log(self.channels[c.pid])
		#log(f"calling update_hotlist {msg['product_id']}")
		
		#102825 HOTLIST:
		#rval = self.update_hotlist(msg['product_id'])
		#log(rval)

	def subscribe_new(self):
		channel = 'ticker'
		timestamp = str(int(time.time()))
		subscribe_msg = {
			'type': 'subscribe',
			"channels": [
   			 { "name": "ticker", "product_ids": self.subscribed_products_list }
  			],
			'api_key': API_KEY,
			'timestamp': timestamp,
			'signature': self.sign_message(timestamp + channel + self.subscribed_products_string)
		}
		#plog(subscribe_msg)
		subscribe_msg = json.dumps(subscribe_msg)

		def on_open(ws):
			self.CBX_FEED.send(subscribe_msg)
		
		def mkOldFmt(msg):
			#log(f"mkOldFmt")
			try:
				rval ={
					"best_ask": "0",
					"best_ask_size": "0",
					"best_bid": "0",
					"best_bid_size": "0",
					"high_24h": msg["high_24h"],
					"last_size": msg["last_size"],
					"low_24h": msg["low_24h"],
					"open_24h": str(self.channels[msg["product_id"]].open_24h) if msg.get("product_id") in self.channels else "0",
					"price": msg["price"],
					"product_id": msg["product_id"],
					"sequence": msg["sequence"],
					"side": msg["side"],
					"time": msg["time"],
					"trade_id": 0,
					"type": "ticker",
					"volume_24h": msg["volume_24h"],
					"volume_30d": msg["volume_30d"]
				}
				return rval
			except:
				log(f"{sys.exc_info()}")
			return None

		def on_message(ws, raw_msg):
			msg=json.loads(raw_msg)#ticker update from coinbase
			#plog(msg)
			if msg['type']=="error":
				#log(f"{raw_msg}")
				product_id=msg['reason'].split(" ")[0]
				self.subscribed_products_list.remove(product_id)
				return
			
			elif msg['type']=='subscriptions':
				self.subscribed_products_list=msg['channels']['product_ids']
				return

			elif msg['type']!='ticker':
				log(f'not a ticker message {raw_msg}')
				return
			
			self.t_last_ticker=time.time()

			msg=mkOldFmt(msg)
			#plog(msg)
			#print(f"{self.ctx.wss.connections}")
			"""
			if msg['product_id'] == 'BTC-USD' and self.subscribeBTC:
				for wskey in self.ctx.wss.connections:
					self.ctx.wss.queues[wskey].append(json.dumps(msg))
					#log(f"self.ctx.wss.queues = {self.ctx.wss.queues}")
			elif msg['product_id'] == 'ETH-USD' and self.subscribeETH:
				for wskey in self.ctx.wss.connections:
					self.ctx.wss.queues[wskey].append(json.dumps(msg))
			elif msg['product_id'] in self.sendlist:#msg['product_id'] in self.channels and (self.channels[msg['product_id']].lookAtMePCT == True or self.channels[msg['product_id']].lookAtMeVOL == True):
				for wskey in self.ctx.wss.connections:#NEED:sendlist is currently default GRT only
					self.ctx.wss.queues[wskey].append(json.dumps(msg))
			"""
			#print(f"{len(self.ctx.wss.queues[wskey])}")
			self.update_channel(msg)

		def on_close(ws):
			log('Websocket connection closed')

		self.CBX_FEED = websocket.WebSocketApp(
			WS_CBX_FEED,
			on_message=on_message
		)
		self.CBX_FEED.on_open = on_open
		self.CBX_FEED.on_close = on_close
		self.CBX_FEED.run_forever()

	def restartCBX(self):
		log(f"restartCBX")
		if self.cbx_thread:
			#self.cbx_thread.join()
			#time.sleep(1)
			self.cbx_thread=None
			self.CBX_FEED=None
		
		self.cbx_thread = threading.Thread(target=self.subscribe_new)
		#websocket_thread.daemon=True
		log(f"calling cbx_thread.start()")
		self.cbx_thread.start()

	def sign_message(self,message):
		message = hmac.new(API_SECRET.encode('utf-8'), message.encode('utf-8'), digestmod=hashlib.sha256).hexdigest()
		return message

	def sendZ25D(self):
		log('sendZ25D')
		z25state = {#these are client subscriptions (sets of pids of which to send), not cbx
			'type':'z25d',
			'subscribeVol':self.subscribeVol,
			'subscribePct':self.subscribePct,
			'subscribeBal':self.subscribeBal,
			'subscribeBTC':self.subscribeBTC,
			'subscribeETH':self.subscribeETH,
			'pctThresh':self.pctThresh,
			'volThresh':self.volThresh,
			'nbin':DEFAULT_NBIN,
			'dt':DEFAULT_DT,
			'numChannels':len(list(self.channels.keys())),
			'cbxMsgsReceived':0,
			'cbxMsgsSent':0,
			'clientMsgsReceived':0,
			'clientMsgsSent':0,
			'sendlist':self.sendlist,
		}
		json_state = json.dumps(z25state)
		log(json_state)
		for wskey in list(self.ctx.wss.connections):
			log('sending json_state to {}'.format(wskey))
			self.ctx.wss.queues[wskey].append(json_state)

	def getAllChannels(self):
		collective_block_update = {'type':'collective_block_update',}
		for c in self.channels.values():
			collective_block_update[c.pid] = c.block_update()
		for wskey in list(self.ctx.wss.connections):
			self.ctx.wss.queues[wskey].append(json.dumps(collective_block_update))

	def sendBlockUpdateNow(self):
		collective_block_update = {'type':'collective_block_update',}
		lookAtMeCountVOL=0
		lookAtMeCountPCT=0
		for c in self.channels.values():
			#log('{} {} {:.3f}'.format(c.pid, c.count, float(c.price)))
			retain = False

			if c.pid == 'BTC-USD' and self.subscribeBTC:
				retain = True
			
			if c.pid == 'ETH-USD' and self.subscribeETH:
				retain = True
			
			if c.lookAtMeVOL:
				lookAtMeCountVOL += 1
				if self.subscribeVol:
					retain = True
			
			if c.lookAtMePCT:
				lookAtMeCountPCT += 1
				if self.subscribePct:
					retain = True

			if c.balance and self.subscribeBal:
				retain = True
			
			if c.subscribed:#ie manually subscribed, and persistent
				retain = True	

			if retain == True:
				collective_block_update[c.pid] = c.block_update()

		#log('lookAtMeCountVOL: {} lookAtMeCountPCT: {}'.format(lookAtMeCountVOL,lookAtMeCountPCT))
		for wskey in list(self.ctx.wss.connections):
			self.ctx.wss.queues[wskey].append(json.dumps(collective_block_update))

	def clearLookAtMe(self):
		print(f"z25.clearLookAtMe")
		self.sendlist=[]
		self.subscribed_products_list=[]
		self.subscribed_products_string=""
		self.hotlist={}
		for c in self.channels.values():
			c.lookAtMePct=False
			c.lookAtMeVol=False
			c.subscribed=False
		for wskey in list(self.ctx.wss.connections):
			self.ctx.wss.queues[wskey]=[]
		for c in self.channels.values():
			if c.lookAtMePct==True:
				print(f"WHOA! {c.pid} lookAtMePct: {c.lookAtMePct} {self.channels[c.pid].lookAtMePct}")
			if c.lookAtMeVol==True:
				print(f"WHOA! {c.pid} lookAtMeVol: {c.lookAtMeVol} {self.channels[c.pid].lookAtMeVol}")

	def take_settings(self,msg):
		log("take_settings")
		self.volThresh=msg['volThresh']
		self.pctThresh=msg['pctThresh']
		self.subscribeBTC=msg['subscribeBTC']
		self.subscribeETH=msg['subscribeETH']
		self.subscribePct=msg['subscribePct']
		self.subscribeVol=msg['subscribeVol']
		self.subscribeBal=msg['subscribeBal']
		#
		for c in self.channels.values():
			c.setThresh(self.pctThresh, self.volThresh)
		
	def subscribe(self, pid):
		self.channels[pid].subscribed=True

	def unsubscribe(self, pid):
		self.channels[pid].subscribed=False

	def report(self):
		log(f"z25.report")
		log(f"pct-thresh: {self.pctThresh} vol-thresh:{self.volThresh}")
		log(f"t_last_ticker: {self.t_last_ticker}")
		log(f"tnext: {self.tnext}")
		log(f"sendlist: {self.sendlist}")
		log(f"subscribed: {self.subscribed_products_list}")
		log(f"subscribed: {self.subscribed_products_string}")

		print(f"self.pctThresh: {self.pctThresh}")
		print(f"self.volThresh: {self.volThresh}")
		print(f"self.subscribeBTC: {self.subscribeBTC}")
		print(f"self.subscribeETH: {self.subscribeETH}")
		print(f"self.subscribePct: {self.subscribePct}")
		print(f"self.subscribeVol: {self.subscribeVol}")
		print(f"self.subscribeBal: {self.subscribeBal}")

		#for c in self.channels:c.report()

if __name__=="__main__":
	z25d=Z25d()
	try:
		z25d.start()
	except:
		z25d.save_state()
		sys.exit()

"""
{
	"best_ask": "111670.07",
	"best_ask_size": "0.10681918",
	"best_bid": "111670.06",
	"best_bid_size": "0.01732166",
	"high_24h": "111968.52",
	"last_size": "0.00118205",
	"low_24h": "110693.01",
	"open_24h": "111042.13",
	"price": "111670.06",
	"product_id": "BTC-USD",
	"sequence": 114244292687,
	"side": "sell",
	"time": "2025-10-25T23:17:05.912923Z",
	"trade_id": 891776535,
	"type": "ticker",
	"volume_24h": "1423.09388994",
	"volume_30d": "241615.25295228"
}
"""